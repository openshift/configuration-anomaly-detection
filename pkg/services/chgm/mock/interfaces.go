// Code generated by MockGen. DO NOT EDIT.
// Source: chgm.go

// Package mock is a generated GoMock package.
package mock

import (
	reflect "reflect"

	cloudtrail "github.com/aws/aws-sdk-go/service/cloudtrail"
	ec2 "github.com/aws/aws-sdk-go/service/ec2"
	gomock "github.com/golang/mock/gomock"
	v1 "github.com/openshift-online/ocm-sdk-go/clustersmgmt/v1"
	ocm "github.com/openshift/configuration-anomaly-detection/pkg/ocm"
	pagerduty "github.com/openshift/configuration-anomaly-detection/pkg/pagerduty"
)

// MockService is a mock of Service interface.
type MockService struct {
	ctrl     *gomock.Controller
	recorder *MockServiceMockRecorder
}

// MockServiceMockRecorder is the mock recorder for MockService.
type MockServiceMockRecorder struct {
	mock *MockService
}

// NewMockService creates a new mock instance.
func NewMockService(ctrl *gomock.Controller) *MockService {
	mock := &MockService{ctrl: ctrl}
	mock.recorder = &MockServiceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockService) EXPECT() *MockServiceMockRecorder {
	return m.recorder
}

// AddNote mocks base method.
func (m *MockService) AddNote(notes string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddNote", notes)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddNote indicates an expected call of AddNote.
func (mr *MockServiceMockRecorder) AddNote(notes interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddNote", reflect.TypeOf((*MockService)(nil).AddNote), notes)
}

// CreateNewAlert mocks base method.
func (m *MockService) CreateNewAlert(newAlert pagerduty.NewAlert, serviceID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateNewAlert", newAlert, serviceID)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateNewAlert indicates an expected call of CreateNewAlert.
func (mr *MockServiceMockRecorder) CreateNewAlert(newAlert, serviceID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateNewAlert", reflect.TypeOf((*MockService)(nil).CreateNewAlert), newAlert, serviceID)
}

// DeleteLimitedSupportReasons mocks base method.
func (m *MockService) DeleteLimitedSupportReasons(ls ocm.LimitedSupportReason, clusterID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteLimitedSupportReasons", ls, clusterID)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteLimitedSupportReasons indicates an expected call of DeleteLimitedSupportReasons.
func (mr *MockServiceMockRecorder) DeleteLimitedSupportReasons(ls, clusterID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteLimitedSupportReasons", reflect.TypeOf((*MockService)(nil).DeleteLimitedSupportReasons), ls, clusterID)
}

// EscalateAlertWithNote mocks base method.
func (m *MockService) EscalateAlertWithNote(notes string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EscalateAlertWithNote", notes)
	ret0, _ := ret[0].(error)
	return ret0
}

// EscalateAlertWithNote indicates an expected call of EscalateAlertWithNote.
func (mr *MockServiceMockRecorder) EscalateAlertWithNote(notes interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EscalateAlertWithNote", reflect.TypeOf((*MockService)(nil).EscalateAlertWithNote), notes)
}

// GetClusterMachinePools mocks base method.
func (m *MockService) GetClusterMachinePools(clusterID string) ([]*v1.MachinePool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetClusterMachinePools", clusterID)
	ret0, _ := ret[0].([]*v1.MachinePool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetClusterMachinePools indicates an expected call of GetClusterMachinePools.
func (mr *MockServiceMockRecorder) GetClusterMachinePools(clusterID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetClusterMachinePools", reflect.TypeOf((*MockService)(nil).GetClusterMachinePools), clusterID)
}

// GetServiceID mocks base method.
func (m *MockService) GetServiceID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetServiceID")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetServiceID indicates an expected call of GetServiceID.
func (mr *MockServiceMockRecorder) GetServiceID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetServiceID", reflect.TypeOf((*MockService)(nil).GetServiceID))
}

// IsInLimitedSupport mocks base method.
func (m *MockService) IsInLimitedSupport(clusterID string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsInLimitedSupport", clusterID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsInLimitedSupport indicates an expected call of IsInLimitedSupport.
func (mr *MockServiceMockRecorder) IsInLimitedSupport(clusterID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsInLimitedSupport", reflect.TypeOf((*MockService)(nil).IsInLimitedSupport), clusterID)
}

// LimitedSupportReasonExists mocks base method.
func (m *MockService) LimitedSupportReasonExists(ls ocm.LimitedSupportReason, clusterID string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LimitedSupportReasonExists", ls, clusterID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LimitedSupportReasonExists indicates an expected call of LimitedSupportReasonExists.
func (mr *MockServiceMockRecorder) LimitedSupportReasonExists(ls, clusterID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LimitedSupportReasonExists", reflect.TypeOf((*MockService)(nil).LimitedSupportReasonExists), ls, clusterID)
}

// ListNonRunningInstances mocks base method.
func (m *MockService) ListNonRunningInstances(infraID string) ([]*ec2.Instance, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListNonRunningInstances", infraID)
	ret0, _ := ret[0].([]*ec2.Instance)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListNonRunningInstances indicates an expected call of ListNonRunningInstances.
func (mr *MockServiceMockRecorder) ListNonRunningInstances(infraID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListNonRunningInstances", reflect.TypeOf((*MockService)(nil).ListNonRunningInstances), infraID)
}

// ListRunningInstances mocks base method.
func (m *MockService) ListRunningInstances(infraID string) ([]*ec2.Instance, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListRunningInstances", infraID)
	ret0, _ := ret[0].([]*ec2.Instance)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListRunningInstances indicates an expected call of ListRunningInstances.
func (mr *MockServiceMockRecorder) ListRunningInstances(infraID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListRunningInstances", reflect.TypeOf((*MockService)(nil).ListRunningInstances), infraID)
}

// PollInstanceStopEventsFor mocks base method.
func (m *MockService) PollInstanceStopEventsFor(instances []*ec2.Instance, retryTimes int) ([]*cloudtrail.Event, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PollInstanceStopEventsFor", instances, retryTimes)
	ret0, _ := ret[0].([]*cloudtrail.Event)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PollInstanceStopEventsFor indicates an expected call of PollInstanceStopEventsFor.
func (mr *MockServiceMockRecorder) PollInstanceStopEventsFor(instances, retryTimes interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PollInstanceStopEventsFor", reflect.TypeOf((*MockService)(nil).PollInstanceStopEventsFor), instances, retryTimes)
}

// PostLimitedSupportReason mocks base method.
func (m *MockService) PostLimitedSupportReason(limitedSupportReason ocm.LimitedSupportReason, clusterID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PostLimitedSupportReason", limitedSupportReason, clusterID)
	ret0, _ := ret[0].(error)
	return ret0
}

// PostLimitedSupportReason indicates an expected call of PostLimitedSupportReason.
func (mr *MockServiceMockRecorder) PostLimitedSupportReason(limitedSupportReason, clusterID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PostLimitedSupportReason", reflect.TypeOf((*MockService)(nil).PostLimitedSupportReason), limitedSupportReason, clusterID)
}

// SilenceAlertWithNote mocks base method.
func (m *MockService) SilenceAlertWithNote(notes string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SilenceAlertWithNote", notes)
	ret0, _ := ret[0].(error)
	return ret0
}

// SilenceAlertWithNote indicates an expected call of SilenceAlertWithNote.
func (mr *MockServiceMockRecorder) SilenceAlertWithNote(notes interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SilenceAlertWithNote", reflect.TypeOf((*MockService)(nil).SilenceAlertWithNote), notes)
}

// UnrelatedLimitedSupportExists mocks base method.
func (m *MockService) UnrelatedLimitedSupportExists(ls ocm.LimitedSupportReason, clusterID string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnrelatedLimitedSupportExists", ls, clusterID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnrelatedLimitedSupportExists indicates an expected call of UnrelatedLimitedSupportExists.
func (mr *MockServiceMockRecorder) UnrelatedLimitedSupportExists(ls, clusterID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnrelatedLimitedSupportExists", reflect.TypeOf((*MockService)(nil).UnrelatedLimitedSupportExists), ls, clusterID)
}
